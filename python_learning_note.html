<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>python learning note</title>
<!-- 2020-02-10 一 15:40 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Li Gao-Yang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">python learning note</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. python support in org mode</a>
<ul>
<li><a href="#sec-1-1">1.1. python code block</a></li>
<li><a href="#sec-1-2">1.2. inline calling</a></li>
<li><a href="#sec-1-3">1.3. plotting</a></li>
</ul>
</li>
<li><a href="#sec-2">2. A primer on scientific programming with python</a>
<ul>
<li><a href="#sec-2-1">2.1. using a program as a calculator</a></li>
<li><a href="#sec-2-2">2.2. using variables</a></li>
<li><a href="#sec-2-3">2.3. Important print syntax</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Liaoxuefeng python3</a>
<ul>
<li><a href="#sec-3-1">3.1. python 基础</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. 数据类型</a></li>
<li><a href="#sec-3-1-2">3.1.2. Important 字符串与编码</a></li>
<li><a href="#sec-3-1-3">3.1.3. list与tuple <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-03 Thu&gt;</span></span></a></li>
<li><a href="#sec-3-1-4">3.1.4. Important 条件判断 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-04 Fri&gt;</span></span></a></li>
<li><a href="#sec-3-1-5">3.1.5. 循环 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-04 Fri&gt;</span></span></a></li>
<li><a href="#sec-3-1-6">3.1.6. 使用dict <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-05 Sat&gt;</span></span></a></li>
<li><a href="#sec-3-1-7">3.1.7. 使用set <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-05 Sat&gt;</span></span></a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2. 函数</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1. 调用函数 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-06 Sun&gt;</span></span></a></li>
<li><a href="#sec-3-2-2">3.2.2. 数据类型转换 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-06 Sun&gt;</span></span></a></li>
<li><a href="#sec-3-2-3">3.2.3. 定义函数 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-06 Sun&gt;</span></span></a></li>
<li><a href="#sec-3-2-4">3.2.4. 函数的参数 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-07 Mon&gt;</span></span></a></li>
<li><a href="#sec-3-2-5">3.2.5. <span class="todo TODO">TODO</span> 递归函数 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-07 Mon&gt;</span></span></a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3. 高级特性</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1. slice 切片 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-07 Mon&gt;</span></span></a></li>
<li><a href="#sec-3-3-2">3.3.2. iteration 迭代 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-08 Tue&gt;</span></span></a></li>
<li><a href="#sec-3-3-3">3.3.3. list comprehensions 列表生成式 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-21 Mon&gt;</span></span></a></li>
<li><a href="#sec-3-3-4">3.3.4. generator 生成器 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-24 Thu&gt;</span></span></a></li>
<li><a href="#sec-3-3-5">3.3.5. Iterator 迭代器 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-25 Fri&gt;</span></span></a></li>
</ul>
</li>
<li><a href="#sec-3-4">3.4. <span class="todo TODO">TODO</span> 函数式编程</a></li>
<li><a href="#sec-3-5">3.5. module 模块<span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-25 Fri&gt;</span></span></a>
<ul>
<li><a href="#sec-3-5-1">3.5.1. 使用module <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-06-06 Wed&gt;</span></span></a></li>
<li><a href="#sec-3-5-2">3.5.2. 作用域 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-06-06 Wed&gt;</span></span></a></li>
<li><a href="#sec-3-5-3">3.5.3. 安装第三方模块 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-06-07 Thu&gt;</span></span></a></li>
<li><a href="#sec-3-5-4">3.5.4. 安装常用模块 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-06-07 Thu&gt;</span></span></a></li>
</ul>
</li>
<li><a href="#sec-3-6">3.6. 面向对象编程 Object Oriented Programming</a>
<ul>
<li><a href="#sec-3-6-1">3.6.1. 类与实例 Class Instance</a></li>
<li><a href="#sec-3-6-2">3.6.2. 访问限制 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-06-29 Fri&gt;</span></span></a></li>
<li><a href="#sec-3-6-3">3.6.3. 继承与多态 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-07-05 Thu&gt;</span></span></a></li>
<li><a href="#sec-3-6-4">3.6.4. 获取对象信息 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-08-10 Fri&gt;</span></span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. Tensor flow 中文社区</a>
<ul>
<li><a href="#sec-4-1">4.1. 介绍</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1. intro<sub>mnist</sub></a></li>
<li><a href="#sec-4-1-2">4.1.2. expert<sub>mnist</sub></a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2. MNIST introduction</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Google机器学习速成课程</a></li>
<li><a href="#sec-6">6. Python 命令笔记</a>
<ul>
<li><a href="#sec-6-1">6.1. <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-21 Mon&gt;</span></span></a></li>
<li><a href="#sec-6-2">6.2. <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-24 Thu&gt;</span></span></a></li>
</ul>
</li>
<li><a href="#sec-7">7. Plot scientific data using python</a>
<ul>
<li><a href="#sec-7-1">7.1. 'Colors in the default prop<sub>cycle</sub></a></li>
</ul>
</li>
<li><a href="#sec-8">8. git@github.com:lijin-THU/notes-python.git</a>
<ul>
<li><a href="#sec-8-1">8.1. 基础</a>
<ul>
<li><a href="#sec-8-1-1">8.1.1. 文件读写 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-04 Tue&gt;</span></span></a></li>
</ul>
</li>
<li><a href="#sec-8-2">8.2. numpy <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-04 Tue 11:14&gt;</span></span></a>
<ul>
<li><a href="#sec-8-2-1">8.2.1. overview <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-08 Sat&gt;</span></span></a></li>
<li><a href="#sec-8-2-2">8.2.2. matplotlib basics <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-08 Sat 17:11&gt;</span></span></a></li>
<li><a href="#sec-8-2-3">8.2.3. numpy array <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-08 Sat 18:12&gt;</span></span></a></li>
<li><a href="#sec-8-2-4">8.2.4. array types <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-09 Sun 15:47&gt;</span></span></a></li>
<li><a href="#sec-8-2-5">8.2.5. array calculation method <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-09 Sun 16:57&gt;</span></span></a></li>
<li><a href="#sec-8-2-6">8.2.6. numpy sorting <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-09 Sun&gt;</span></span></a></li>
</ul>
</li>
<li><a href="#sec-8-3">8.3. <span class="todo TODO">TODO</span> interfacing with other languages <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-10-03 Wed&gt;</span></span></a></li>
</ul>
</li>
<li><a href="#sec-9">9. Coursera-ML-AndrewNg-Notes</a>
<ul>
<li><a href="#sec-9-1">9.1. <span class="timestamp-wrapper"><span class="timestamp">&lt;2019-03-30 六 01:00&gt;</span></span> 课时12 梯度下降</a></li>
</ul>
</li>
<li><a href="#sec-10">10. TensorFlow learning on Github</a>
<ul>
<li><a href="#sec-10-1">10.1. 疑问</a></li>
</ul>
</li>
<li><a href="#sec-11">11. Handson-ml</a>
<ul>
<li><a href="#sec-11-1">11.1. numpy and pandas</a>
<ul>
<li><a href="#sec-11-1-1">11.1.1. creating arrays and learning pandas <span class="timestamp-wrapper"><span class="timestamp">&lt;2020-01-23 Thu&gt;</span></span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> python support in org mode</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> python code block</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">

<pre class="src src-python">return 2/3
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python">print(2/3)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python">print(2/3)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> inline calling</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Two plus two equals <code>4</code>
</p>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> plotting</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">

<pre class="src src-python">import matplotlib, numpy
matplotlib.use('Agg')
import matplotlib.pyplot as plt
fig=plt.figure(figsize=(4,2))
x=numpy.linspace(-15,15)
plt.plot(numpy.sin(x)/x)
fig.tight_layout()
plt.savefig('python-matplot-fig.png')
return 'python-matplot-fig.png' # return filename to org-mode
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> A primer on scientific programming with python</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> using a program as a calculator</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-python">print(5*0.6 - 0.5*9.81*0.6**2)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> using variables</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">

<pre class="src src-python">v0 = 5
g = 9.81
t = 0.6
y = v0*t - 0.5*g*t**2
print(y)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Important print syntax</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>State "Important"  from ""           <span class="timestamp-wrapper"><span class="timestamp">[2018-05-06 Sun 13:48]</span></span>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">v0 = 5
g = 9.81
t = 0.6
y = v0*t - 0.5*g*t**2
print('At t=%g s, the height of the ball is %.2f m.' % (t,y))
</pre>
</div>
<div class="org-src-container">

<pre class="src src-python">print("""y(t) is
the position of
our ball.""")
print()
print('y(t) is\nthe position of\nour ball')
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Liaoxuefeng python3</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> python 基础</h3>
<div class="outline-text-3" id="text-3-1">
<p>
以#开头的语句是注释
每一行都是一个语句
当语句以冒号:结尾时，缩进的语句视为代码块。
应该始终坚持使用4个空格的缩进。
Python程序是大小写敏感的
</p>

<div class="org-src-container">

<pre class="src src-python">a = 100
if a &gt;= 0:
    print(a)
else:
    print(-a)
</pre>
</div>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> 数据类型</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>整数
Python可以处理任意大小的整数
</li>
<li>浮点数
</li>
<li>字符串
<ul class="org-ul">
<li>字符串是以单引号'或双引号"括起来的任意文本
</li>
<li>如果'本身也是一个字符，那就可以用""括起来
</li>
<li>如果字符串内部既包含'又包含",可以用转义字符\来标识
</li>
<li>允许用r''表示''内部的字符串默认不转义
</li>
<li>允许用'''&#x2026;'''的格式表示多行内容
</li>
</ul>
</li>
<li>布尔值
<ul class="org-ul">
<li>只有True、False两种值
</li>
<li>and or not
</li>
</ul>
</li>
<li>空值none
</li>
<li>变量，动态语言与静态语言
</li>
<li>常量
<ul class="org-ul">
<li>通常用全部大写的变量名表示常量
</li>
</ul>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">print('I\'m ok.')
print('I\'m learning\nPython.')
print('\\\n\\')
print(r'''hello,\n
world''')
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> Important 字符串与编码</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>State "Important"  from ""           <span class="timestamp-wrapper"><span class="timestamp">[2018-05-03 Thu 10:49]</span></span>
</li>
</ul>
<ul class="org-ul">
<li>%运算符就是用来格式化字符串的。
</li>
<li>在字符串内部，%s表示用字符串替换，
</li>
<li>%d表示用整数替换，
</li>
<li>有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。
</li>
<li>如果只有一个%?，括号可以省略。
</li>
<li>格式化整数和浮点数还可以指定是否补0和整数与小数的位数
</li>
<li>%s永远起作用，它会把任何数据类型转换为字符串
</li>

<li>%d        整数
</li>
<li>%f        浮点数
</li>
<li>%s        字符串
</li>
<li>%x        十六进制整数
</li>
</ul>

<div class="org-src-container">

<pre class="src src-python">print('Hello, %s' % 'world')
print('Hi, %s, you have $%d.' % ('Michael', 1000000))
print('%4d-%0004d' % (3, 1))
print('%.2f' % 3.1415926)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3"><span class="section-number-4">3.1.3</span> list与tuple <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-03 Thu&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-1-3">
</div><ol class="org-ol"><li><a id="sec-3-1-3-1" name="sec-3-1-3-1"></a>list<br  /><div class="outline-text-5" id="text-3-1-3-1">
<ul class="org-ul">
<li>索引是从0开始
</li>
<li>用-1做索引，直接获取最后一个元素
</li>
<li>往list中追加元素到末尾, classmates.append('Adam')
</li>
<li>把元素插入到指定的位置, classmates.insert(1,'Jack')
</li>
<li>删除list末尾的元素，用pop()
</li>
<li>删除指定位置的元素，用pop(i)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">classmates = ['Michael', 'Bob', 'Tracy']
print(classmates)
print(len(classmates))
print(classmates[-3])
classmates.append('Adam')
print(classmates)
</pre>
</div>
</div>
</li>
<li><a id="sec-3-1-3-2" name="sec-3-1-3-2"></a>tuple<br  /><div class="outline-text-5" id="text-3-1-3-2">
<p>
tuple和list非常类似，但是tuple一旦初始化就不能修改
</p>
<div class="org-src-container">

<pre class="src src-python">classmates = ('Michael', 'Bob', 'Tracy')
t = (1,)
print(classmates, len(t),t[-1])
</pre>
</div>
</div>
</li></ol>
</div>

<div id="outline-container-sec-3-1-4" class="outline-4">
<h4 id="sec-3-1-4"><span class="section-number-4">3.1.4</span> Important 条件判断 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-04 Fri&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-1-4">
<ul class="org-ul">
<li>State "Important"  from ""           <span class="timestamp-wrapper"><span class="timestamp">[2018-05-04 Fri 09:30]</span></span>
</li>
<li>if语句的完整形式
if &lt;条件判断1&gt;:
    &lt;执行1&gt;
elif &lt;条件判断2&gt;:
    &lt;执行2&gt;
elif &lt;条件判断3&gt;:
    &lt;执行3&gt;
else:
    &lt;执行4&gt;
</li>
</ul>
<p>
它是从上往下判断，如果在某个判断上是True，
把该判断对应的语句执行后，就忽略掉剩下的elif和else.
##########################################################################
</p>
<ul class="org-ul">
<li>只要条件为非零数值、非空字符串、非空list等，就判断为True，否则为False。#
</li>
</ul>
<p>
##########################################################################
</p>
</div>
</div>
<div id="outline-container-sec-3-1-5" class="outline-4">
<h4 id="sec-3-1-5"><span class="section-number-4">3.1.5</span> 循环 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-04 Fri&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-1-5">
<ul class="org-ul">
<li>for x in list:
</li>
<li>while x :
</li>
<li>break
</li>
<li>continue
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">print(range(5))
print(list(range(5)))
for i in range(5):
    print(i)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-1-6" class="outline-4">
<h4 id="sec-3-1-6"><span class="section-number-4">3.1.6</span> 使用dict <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-05 Sat&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-1-6">
<p>
dict全称dictionary，在其他语言中也称为map，
使用键-值（key-value）存储，具有极快的查找速度。
把数据放入dict的方法，除了初始化时指定外，还可以通过key放入
要避免key不存在的错误，有两种办法:
</p>
<ul class="org-ul">
<li>通过in判断key是否存在
</li>
<li>通过dict提供的get()方法，如果key不存在，
可以返回None，或者自己指定的value
</li>
</ul>
<p>
要删除一个key，用pop(key)方法，对应的value也会从dict中删除
请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的
##########################################################
##  和list比较，dict有以下几个特点：
##  查找和插入的速度极快，不会随着key的增加而变慢；
##  需要占用大量的内存，内存浪费多。
##
##  而list相反：
##  查找和插入的时间随着元素的增加而增加；
##  占用空间小，浪费内存很少。
##  所以，dict是用空间来换取时间的一种方法。
##########################################################
</p>
<ul class="org-ul">
<li>哈希算法（Hash）
</li>
<li>作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，
因此，可以放心地作为key。而list是可变的，就不能作为key
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">d={'Michael': 95, 'Bob':75, 'Tracy':85}
d['Adam'] = 67
print(d['Michael'])
print('Adam' in d)
print(d.get('Tom', 0))
print(d.pop('Bob'))
print(d)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-1-7" class="outline-4">
<h4 id="sec-3-1-7"><span class="section-number-4">3.1.7</span> 使用set <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-05 Sat&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-1-7">
<ul class="org-ul">
<li>set和dict类似，也是一组key的集合，但不存储value。
由于key不能重复，所以，在set中，没有重复的key。
</li>
<li>通过add(key)方法可以添加元素到set中
</li>
<li>过remove(key)方法可以删除元素
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">s = set([1, 2, 3])
print(s)
s1 = set([1, 2, 3])
s2 = set([2, 3, 4])
print(s1 &amp; s2)
print(s1 | s2)
print(set((1,2,3)))
# print(set((1,[2,3])))
new_dict={'Wang':59}
new_dict['Ligy']=100
print(new_dict)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 函数</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> 调用函数 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-06 Sun&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>可以在交互式命令行通过help(abs)查看abs函数的帮助信息
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> 数据类型转换 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-06 Sun&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li>int('123')
</li>
<li>float('12.4')
</li>
<li>str(1.2)
</li>
<li>bool(1)
</li>
<li>bool('')
</li>
<li>函数名其实就是指向一个函数对象的引用，
完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">print(bool("2"))
a = abs
print(a(-9))
tuple_={'255':hex(int('255'))}
tuple_['1000']=hex(int('1000'))
print(tuple_['255'],tuple_['1000'])
print('255的16进制表示为%s\n1000的16进制表示为%s' % (hex(255), hex(1000)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> 定义函数 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-06 Sun&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>定义一个函数要使用def语句，依次写出函数名、括号、
括号中的参数和冒号:，然后，在缩进块中编写函数体，
函数的返回值用return语句返回。
</li>
<li>函数体内部的语句在执行时，一旦执行到return时，
函数就执行完毕，并将结果返回
</li>
<li>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None
</li>
<li>果你已经把my<sub>abs</sub>()的函数定义保存为abstest.py文件了，
那么，可以在该文件的当前目录下启动Python解释器，
用from abstest import my<sub>abs来导入my</sub><sub>abs</sub>()函数，
注意abstest是文件名（不含.py扩展名）
</li>
<li>pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，
比如现在还没想好怎么写函数的代码，就可以先放一个pass，
让代码能运行起来。
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">def my_print(x):
    print('what\'s up man?')
    # return x*x
a=my_print(3)
print(a)
</pre>
</div>
</div>
<ol class="org-ol"><li><a id="sec-3-2-3-1" name="sec-3-2-3-1"></a>空函数<br  /></li>
<li><a id="sec-3-2-3-2" name="sec-3-2-3-2"></a>参数检查<br  /><div class="outline-text-5" id="text-3-2-3-2">
<p>
数据类型检查可以用内置函数isinstance()实现。
</p>
<div class="org-src-container">

<pre class="src src-python">def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x &gt;= 0:
        return x
    else:
        return -x
my_abs('A')
</pre>
</div>
</div>
</li>
<li><a id="sec-3-2-3-3" name="sec-3-2-3-3"></a>返回多个值<br  /><div class="outline-text-5" id="text-3-2-3-3">
<p>
Python的函数返回多值其实就是返回一个tuple，但写起来更方便
return nx, ny
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-3-2-4" class="outline-4">
<h4 id="sec-3-2-4"><span class="section-number-4">3.2.4</span> 函数的参数 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-07 Mon&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-2-4">
<ul class="org-ul">
<li>位置参数 power(x), power(x, n), 调用函数时，
传入的两个值按照位置顺序依次赋给参数x和n
</li>
<li>默认参数 power(x, n=2)
设置默认参数时，有几点要注意:
<ul class="org-ul">
<li>一是必选参数在前，默认参数在后，否则Python的解释器会报错
</li>
<li>二是当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。
变化小的参数就可以作为默认参数。
</li>
<li>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，
比如调用enroll('Bob', 'M', 7)用在参数age上，
city参数由于没有提供，仍然使用默认值。
</li>
<li>也可以不按顺序提供部分默认参数。
当不按顺序提供部分默认参数时，需要把参数名写上。
</li>
<li>定义默认参数要牢记一点：默认参数必须指向不变对象！
</li>
</ul>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">def add_end(L=[]):
    if L is None:
        L = []
    L.append('END')
    return L
print(add_end())
print(add_end())

def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
print(add_end())
print(add_end())
</pre>
</div>
</div>
<ol class="org-ol"><li><a id="sec-3-2-4-1" name="sec-3-2-4-1"></a><span class="done DONE">DONE</span> 可变参数<br  /><div class="outline-text-5" id="text-3-2-4-1">
<ul class="org-ul">
<li>State "TODO"       from ""           <span class="timestamp-wrapper"><span class="timestamp">[2018-05-07 Mon 19:18]</span></span>
</li>
<li>可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。
</li>
<li>仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，
函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
print(calc(1, 2, 9))
print(calc())
</pre>
</div>
</div>
</li>

<li><a id="sec-3-2-4-2" name="sec-3-2-4-2"></a><span class="todo TODO">TODO</span> 关键字参数<br  /><div class="outline-text-5" id="text-3-2-4-2">
<ul class="org-ul">
<li>State "TODO"       from ""           <span class="timestamp-wrapper"><span class="timestamp">[2018-05-07 Mon 19:19]</span></span>
</li>
</ul>
</div>
</li>
<li><a id="sec-3-2-4-3" name="sec-3-2-4-3"></a><span class="todo TODO">TODO</span> 命名关键字参数<br  /><div class="outline-text-5" id="text-3-2-4-3">
<ul class="org-ul">
<li>State "TODO"       from ""           <span class="timestamp-wrapper"><span class="timestamp">[2018-05-07 Mon 19:20]</span></span>
</li>
</ul>
</div>
</li>
<li><a id="sec-3-2-4-4" name="sec-3-2-4-4"></a><span class="todo TODO">TODO</span> 参数组合<br  /><div class="outline-text-5" id="text-3-2-4-4">
<ul class="org-ul">
<li>State "TODO"       from ""           <span class="timestamp-wrapper"><span class="timestamp">[2018-05-07 Mon 19:20]</span></span>
</li>
</ul>
</div>
</li>
<li><a id="sec-3-2-4-5" name="sec-3-2-4-5"></a><span class="todo TODO">TODO</span> 小结<br  /><div class="outline-text-5" id="text-3-2-4-5">
<ul class="org-ul">
<li>State "TODO"       from ""           <span class="timestamp-wrapper"><span class="timestamp">[2018-05-07 Mon 19:20]</span></span>
</li>
</ul>
</div>
</li></ol>
</div>
<div id="outline-container-sec-3-2-5" class="outline-4">
<h4 id="sec-3-2-5"><span class="section-number-4">3.2.5</span> <span class="todo TODO">TODO</span> 递归函数 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-07 Mon&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-2-5">
<ul class="org-ul">
<li>State "TODO"       from ""           <span class="timestamp-wrapper"><span class="timestamp">[2018-05-07 Mon 19:24]</span></span>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 高级特性</h3>
<div class="outline-text-3" id="text-3-3">
<p>
在Python中，代码不是越多越好，而是越少越好。
代码不是越复杂越好，而是越简单越好。
</p>
</div>
<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> slice 切片 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-07 Mon&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
</p>

<ul class="org-ul">
<li>取前3个元素 L[0:3]
</li>
<li>倒数切片 L[-2:]
</li>
<li>L[:2] 索引 L<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>, L<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>
</li>
<li>空的list也可以用L[:1]的方式索引
</li>
<li>倒序索引 L[-1::-1]
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
print(len(L))
#print(L[:3])
#print(L[1:3])
#print(L[-5])
print(L[-4:100])
print(L[-1::-1])
print(L[0])
N = list(range(40))
print(N[:20:3])
print(N[:])
print((0, 1, 2, 3, 4, 5, 6, 7, 8)[:3])
print('abcdefghi'[::2])
L1=''
print(L1[:-1])
print(len(L1))
def trim(str_):
    if not isinstance(str_, str):
        raise TypeError('bad operand type')

    while str_[:1]==' ':
        str_=str_[1:]
        print(str_)
    while str_[-1:]==' ':
        str_=str_[-len(str_):-2]
        print(str_)
    return str_
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> iteration 迭代 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-08 Tue&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，
这种遍历我们称为迭代（Iteration）。
</li>
<li>在Python中，迭代是通过for &#x2026; in来完成的，而很多语言比如C语言，
迭代list是通过下标完成的，比如Java代码
</li>
<li>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，
只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代
</li>
<li>默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，
如果要同时迭代key和value，可以用for k, v in d.items()。
</li>
<li>由于字符串也是可迭代对象，因此，也可以作用于for循环
</li>
<li>如何判断一个对象是可迭代对象呢？
方法是通过collections模块的Iterable类型判断
</li>
<li>enumerate函数可以把一个list变成索引-元素对，
这样就可以在for循环中同时迭代索引和元素本身
</li>
<li>上面的for循环里，同时引用了两个变量，在Python里是很常见的
，比如下面的代码
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">d = {'a': 1, 'b': 2, 'c': 3}
for k, v in d.items():
    print(k, v)
for ch in 'AbC':
    print(ch, 'Abc'[::-1])
from collections import Iterable
print(isinstance('abc', Iterable)) # str是否可迭代
for i, value in enumerate(['A', 'B', 'C']):
    print(i, value)
for x, y in [(1, 'a'), (2, d), (3, v)]:
    print(x, y)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3"><span class="section-number-4">3.3.3</span> list comprehensions 列表生成式 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-21 Mon&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
列表生成式则可以用一行语句代替循环生成上面的list
</p>
<div class="org-src-container">

<pre class="src src-python">print([x*x for x in range(1,11)])
print([x*x for x in range(1,11) if x%3==0])
print([m+n for m in 'abc' for n in 'xyz'])
import os
print(os.listdir('.'))
print([d for d in os.listdir('.')])
print('ABcd'.lower(), 'fdsa'.upper())
print('abc'[2])
L = ['Hello', 'World', 18, 'Apple', None]
print([s.lower() for s in L if isinstance(s, str)])
print([s.lower() if isinstance(s, str) else s for s in L])
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-4" class="outline-4">
<h4 id="sec-3-3-4"><span class="section-number-4">3.3.4</span> generator 生成器 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-24 Thu&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-3-4">
<p>
受到内存限制，列表容量肯定是有限的,
在Python中，这种一边循环一边计算的机制，称为生成器：generator。
创建一个generator的方法:
</p>
<ul class="org-ul">
<li>第一种方法，只要把一个列表生成式的[]改成()，就创建了一个generator
</li>
<li>另一种，定义包含yield关键字的的函数, 在循环中不断yield.
如果想要拿到返回值，必须捕获StopIteration错误，
返回值包含在StopIteration的value中.
</li>
</ul>
<p>
#杨辉三角
</p>
<div class="org-src-container">

<pre class="src src-python">#杨辉三角
def triangles():
    # n = 0
    # L1 = [1, 0]
    # while True:
    #     if n == 0 :
    #         yield L1[:-1]
    #     elif n == 1 :
    #         L1.insert(1, 1)
    #         yield L1[:-1]
    #     else:
    #         L = []
    #         L.insert(0, 1)
    #         for i in range(1, n):
    #             L.insert(i, L1[i-1] + L1[i])
    #         L.insert(len(L), 1)
    #         yield L
    #         L1 = L
    #     n = n + 1
    # return 'done'

    L = [1]
    yield L
    L = L + [1]
    yield L
    while True:
        L = [1] + [L[i] + L[i+1] for i in range(0, len(L) -1 )] + [1]
        yield L


n = 0
results = []
for t in triangles():
    print(t)
    results.append(t)
    n = n + 1
    if n == 10:
        break
if results == [
    [1],
    [1, 1],
    [1, 2, 1],
    [1, 3, 3, 1],
    [1, 4, 6, 4, 1],
    [1, 5, 10, 10, 5, 1],
    [1, 6, 15, 20, 15, 6, 1],
    [1, 7, 21, 35, 35, 21, 7, 1],
    [1, 8, 28, 56, 70, 56, 28, 8, 1],
    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
]:
    print('测试通过!')
else:
    print('测试失败!')
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python">g=(x*x for x in range(9))
print(next(g))
print(next(g))
print(next(g))
print('????')
for i in g:
    print(i)
print()
def fibnacci(N):
    n,a,b=0,0,1
    while n &lt; N:
        yield b
        a,b=b,a+b
        n=n+1
    return 'done'
f= fibnacci(9)
for i in f:
    print(i)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-5" class="outline-4">
<h4 id="sec-3-3-5"><span class="section-number-4">3.3.5</span> Iterator 迭代器 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-25 Fri&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-3-5">
<p>
可以使用isinstance()判断一个对象是否是Iterable
可以被next()函数调用并不断返回下一个值的对象称为Iterator
生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator
把list、dict、str等Iterable变成Iterator可以使用iter()函数
Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算
</p>
<ul class="org-ul">
<li>凡是可作用于for循环的对象都是Iterable类型
</li>
<li>凡是可作用于next()函数的对象都是Iterator类型
</li>
<li>Python的for循环本质上就是通过不断调用next()函数实现的
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">from collections import Iterable
print(isinstance([], Iterable))
print(isinstance({}, Iterable))
print(isinstance('abs', Iterable))
print(isinstance((x for x in range(9)), Iterable))
print(isinstance(range(9), Iterable))
from collections import Iterator
isinstance((x for x in range(10)), Iterator)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> <span class="todo TODO">TODO</span> 函数式编程</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>State "TODO"       from ""           <span class="timestamp-wrapper"><span class="timestamp">[2018-05-25 Fri 16:52]</span></span>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> module 模块<span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-25 Fri&gt;</span></span></h3>
<div class="outline-text-3" id="text-3-5">
<p>
为了避免模块名冲突，Python引入了按目录来组织模块的方法，
称为Package（包）
</p>
<ul class="org-ul">
<li>一个abc.py的文件就是一个名字叫abc的模块，
</li>
<li>一个xyz.py的文件就是一个名字叫xyz的模块
</li>
<li>每一个包目录下面都会有一个_<sub>init</sub>__.py的文件，这个文件是必须存在的
</li>
<li>abc.py模块的名字就变成了mycompany.abc，类似的，
</li>
<li>xyz.py的模块名变成了mycompany.xyz
</li>
<li><span class="underline"><span class="underline">init</span></span>.py可以是空文件，也可以有Python代码，
因为_<sub>init</sub>__.py本身就是一个模块，而它的模块名就是mycompany
</li>
<li>可以有多级目录，组成多级层次的包结构
</li>
<li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，
检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块
</li>
</ul>
</div>
<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1"><span class="section-number-4">3.5.1</span> 使用module <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-06-06 Wed&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-5-1">
<div class="org-src-container">

<pre class="src src-python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'this is a test module'

__author__ = 'ligy'


import sys

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    print('this is in main')
    test()
</pre>
</div>
<ul class="org-ul">
<li>任何模块代码的第一个字符串都被视为模块的文档注释
</li>
<li>使用<sub>author</sub><sub>变量把作者写进去</sub>
</li>
<li>argv至少有一个元素，因为第一个参数永远是该.py文件的名称
</li>
<li>这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，
最常见的就是运行测试
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-2" class="outline-4">
<h4 id="sec-3-5-2"><span class="section-number-4">3.5.2</span> 作用域 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-06-06 Wed&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>有的函数和变量我们希望仅仅在模块内部使用
</li>
<li>类似_<sub>xxx</sub>_<sub>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，</sub>
  比如上面的_<sub>author</sub>_<sub>，</sub>_<sub>name</sub>__
</li>
<li>类似<sub>xxx和</sub>_<sub>xxx这样的函数或变量就是非公开的（private），</sub>
  不应该被直接引用，比如<sub>abc，</sub>_<sub>abc等</sub>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) &gt; 3:
        return _private_1(name)
    else:
        return _private_2(name)
</pre>
</div>
<ul class="org-ul">
<li>调用greeting()函数不用关心内部的private函数细节，
这也是一种非常有用的代码封装和抽象的方法
</li>
<li>外部不需要引用的函数全部定义成private，
只有外部需要引用的函数才定义为public
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-3" class="outline-4">
<h4 id="sec-3-5-3"><span class="section-number-4">3.5.3</span> 安装第三方模块 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-06-07 Thu&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-5-3">
<p>
pip install pillow
</p>
</div>
</div>
<div id="outline-container-sec-3-5-4" class="outline-4">
<h4 id="sec-3-5-4"><span class="section-number-4">3.5.4</span> 安装常用模块 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-06-07 Thu&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-5-4">
<ul class="org-ul">
<li>anaconda (狂蟒之灾电影）
</li>
<li>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，
搜索路径存放在sys模块的path变量中
</li>
<li>添加自己的搜索目录，有两种方法:
<ul class="org-ul">
<li>sys.path.append('/Users/michael/my<sub>py</sub><sub>scripts'</sub>)
</li>
<li>设置环境变量PYTHONPATH
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> 面向对象编程 Object Oriented Programming</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数.
</li>
<li>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。
</li>
<li>自定义的对象数据类型就是面向对象中的类（Class）的概念。
</li>
<li>数据封装、继承和多态是面向对象的三大特点
</li>
</ul>
</div>
<div id="outline-container-sec-3-6-1" class="outline-4">
<h4 id="sec-3-6-1"><span class="section-number-4">3.6.1</span> 类与实例 Class Instance</h4>
<div class="outline-text-4" id="text-3-6-1">
<ul class="org-ul">
<li>类名通常是大写开头的单词
</li>
<li>创建实例是通过类名+()实现的
</li>
<li>My<sub>students本身则是一个类</sub>
</li>
<li>可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性
</li>
<li>有了_<sub>init</sub>_<sub>方法，在创建实例的时候，就不能传入空的参数了，</sub>
  必须传入与_<sub>init</sub>_<sub>方法匹配的参数，但self不需要传</sub>
</li>
<li>除self之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、
可变参数、关键字参数和命名关键字参数。
</li>
<li>这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法
</li>
<li>义一个方法，除了第一个参数是self外，其他和普通函数一样。
</li>
<li>调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入
</li>
</ul>
<ul class="org-ul">
<li>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，
虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">class My_students(object):
    pass
ligy = My_students()
ligy.name = 'Li Gaoyang'
ligy.age = 26
print(ligy.name, ligy.age)
jjkprint(My_students)
class My_students2():
    def __init__(self, name, score):
        self.name = name
        self.score = score
    def print_score(self):
        print('%s: %s' % (self.name, self.score))
mark = My_students2('Mark', '99')
john = My_students2('John Nash', 100)
john.age = 70
print(mark.name)
mark.print_score()
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-6-2" class="outline-4">
<h4 id="sec-3-6-2"><span class="section-number-4">3.6.2</span> 访问限制 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-06-29 Fri&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-6-2">
<ul class="org-ul">
<li>外部代码还是可以自由地修改一个实例的name、score属性
</li>
<li>bart.score = 99
</li>
<li>实例的变量名如果以_<sub>开头，就变成了一个私有变量（private），</sub>
  只有内部可以访问，外部不能访问
</li>
<li>在方法中，可以对参数做检查，避免传入无效的参数
</li>
<li>以双下划线开头，并且以双下划线结尾的，是特殊变量，
特殊变量是可以直接访问的，不是private变量
</li>
<li>一个下划线开头的实例变量名,但是，请视为私有变量，不要随意访问
</li>
<li>仍然可以通过<sub>Student</sub>_<sub>name来访问</sub>_<sub>name变量，但是强烈建议你不要这么干，</sub>
  因为不同版本的Python解释器可能会把_<sub>name改成不同的变量名</sub>
</li>
<li>表面上看，外部代码“成功”地设置了_<sub>name变量，但实际上这个</sub>_<sub>name变量和class内部的</sub>_<sub>name变量不是一个变量！</sub>
  内部的_<sub>name变量已经被Python解释器自动改成了</sub><sub>Student</sub>_<sub>name，而外部代码给bart新增了一个</sub>_<sub>name变量</sub>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">class Student(object):
    def __init__(self, name, gender):
        self.name = name
        self.__gender = gender
    def set_gender(self, gender):
        self.__gender = gender
    def get_gender(self):
        return self.__gender
bart = Student('Bart', 'male')
if bart.get_gender() != 'male':
    print('测试失败!')
else:
    bart.set_gender('female')
    if bart.get_gender() != 'female':
        print('测试失败!')
    else:
        print('测试成功!')
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-6-3" class="outline-4">
<h4 id="sec-3-6-3"><span class="section-number-4">3.6.3</span> 继承与多态 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-07-05 Thu&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-6-3">
<ul class="org-ul">
<li>继承最大的好处是子类获得了父类的全部功能
</li>
<li>当子类和父类都存在相同的方法时，子类的方法覆盖了父类的方法
</li>
<li>判断一个变量是否是某个类型可以用isinstance()判断
</li>
<li>如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类
</li>
<li>调用方只管调用，不管细节
</li>
</ul>
<p>
“开闭”原：
</p>
<ul class="org-ul">
<li>对扩展开放：允许新增Animal子类
</li>
<li>对修改封闭：不需要修改依赖Animal类型的run<sub>twice</sub>()等函数
</li>
</ul>
<p>
静态语言 vs 动态语言
</p>
<ul class="org-ul">
<li>对于静态语言（例如Java）来说，如果需要传入Animal类型，
则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法
</li>
<li>对于Python这样的动态语言来说，则不一定需要传入Animal类型。
我们只需要保证传入的对象有一个run()方法就可以了
</li>
<li>动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭
,走起路来像鸭子”，那它就可以被看做是鸭子
</li>
</ul>
<p>
小结
</p>
<ul class="org-ul">
<li>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，
子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。
</li>
<li>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">class Animal(object):
    def run(self):
        print('Animal is running...')
class Dog(Animal):
    def run(self):
        print('Dog is running...')
dog1 = Dog()
dog1.run()
dog1.run()
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-6-4" class="outline-4">
<h4 id="sec-3-6-4"><span class="section-number-4">3.6.4</span> 获取对象信息 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-08-10 Fri&gt;</span></span></h4>
<div class="outline-text-4" id="text-3-6-4">
<ul class="org-ul">
<li>使用type()函数来判断对象类型
</li>
<li>可以使用types模块中定义的常量来判断一个对象是否是函数
</li>
<li>总是优先使用isinstance()判断类型，可以将指定类型及其子类"一网打尽"
</li>
<li>获得一个对象的所有属性和方法，可以使用dir()函数
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">print(type(123))
print(type(abs))
print(type('fda')==type(abs))
import types
def fn():
    pass
print(type(fn))
print(type(fn)==types.FunctionType)
print(type((x for x in range(9)))==types.GeneratorType)
print(type([x for x in range(9)]))
print(dir('dafdsa'))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Tensor flow 中文社区</h2>
<div class="outline-text-2" id="text-4">
<p>
url:<a href="http://www.tensorfly.cn/tfdoc/get_started/introduction.html">http://www.tensorfly.cn/tfdoc/get_started/introduction.html</a>
</p>
<div class="org-src-container">

<pre class="src src-python">import tensorflow as tf
</pre>
</div>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 介绍</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> intro<sub>mnist</sub></h4>
<div class="outline-text-4" id="text-4-1-1">
</div><ol class="org-ol"><li><a id="sec-4-1-1-1" name="sec-4-1-1-1"></a>mnist 数据集 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-05 Sat&gt;</span></span><br  /><div class="outline-text-5" id="text-4-1-1-1">
<ul class="org-ul">
<li>mnist.train.images [6000, 28*28]
数据集的标签是0到9的数字，是一个one-hot vector, (只有一个元素为1,其他为0.)
0表示为 [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</li>
<li>mnist.train.labels [6000, 10]
</li>
</ul>
</div>
</li>
<li><a id="sec-4-1-1-2" name="sec-4-1-1-2"></a>softmax regression 介绍<br  /><div class="outline-text-5" id="text-4-1-1-2">
<ul class="org-ul">
<li>softmax模型可以用来给不同的对象分配概率。即使在之后，我们训练更加精细的模型时，
最后一步也需要用softmax来分配概率。
</li>
<li>为了用python实现高效的数值计算，我们通常会使用函数库，比如NumPy，
会把类似矩阵乘法这样的复杂运算使用其他外部语言实现。
不幸的是，从外部计算切换回Python的每一个操作，仍然是一个很大的开销。
</li>
<li>Tensorflow不单独地运行单一的复杂计算，
而是让我们可以先用图描述一系列可交互的计算操作，然后全部一起在Python之外运行。
</li>
</ul>
</div>
</li></ol>
</div>
<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> expert<sub>mnist</sub></h4>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> MNIST introduction</h3>
<div class="outline-text-3" id="text-4-2">
<p>
在机器学习模型设计时必须有一个单独的测试数据集不用于训练
而是用来评估这个模型的性能，从而更加容易把设计的模型推广
到其他数据集上（泛化）。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Google机器学习速成课程</h2>
<div class="outline-text-2" id="text-5">
<p>
url:<a href="https://developers.google.cn/machine-learning/crash-course/">https://developers.google.cn/machine-learning/crash-course/</a>
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Python 命令笔记</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-21 Mon&gt;</span></span></h3>
<div class="outline-text-3" id="text-6-1">
<p>
os.listdir('.')
'AbC'.lower()
'AbC'.upper()
'abc'<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>
for k, v in {'x': 'A', 'y': 'B'}.items():
    pass
L=[]
L.append(x)
L.pop()
L.pop(3)
d.pop('Jack')
</p>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-05-24 Thu&gt;</span></span></h3>
<div class="outline-text-3" id="text-6-2">
<p>
可迭代对象：
</p>
<ul class="org-ul">
<li>list
</li>
<li>tuple
</li>
<li>range(9)
</li>
<li>dictionary
</li>
<li>set
</li>
<li>str
</li>
<li>generator
<ul class="org-ul">
<li>生成器
</li>
<li>generator function
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Plot scientific data using python</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 'Colors in the default prop<sub>cycle</sub></h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">

<pre class="src src-python">import numpy as np
import matplotlib.pyplot as plt
prop_cycle = plt.rcParams['axes.prop_cycle']
colors = prop_cycle.by_key()['color']
lwbase = plt.rcParams['lines.linewidth']
thin = lwbase / 2
thick = lwbase * 3
fig, axs = plt.subplots(nrows=2, ncols=2, sharex=True, sharey=True)
for icol in range(2):
    if icol == 0:
        lwx, lwy = thin, lwbase
    else:
        lwx, lwy = lwbase, thick
    for irow in range(2):
        for i, color in enumerate(colors):
            axs[irow, icol].axhline(i, color=color, lw=lwx, label=color)
            axs[irow, icol].axvline(i, color=color, lw=lwy)
        plt.legend()
for irow in range(2):
    axs[irow, 0].yaxis.set_ticks(np.arange(0, 10, 2))
fig.suptitle('Colors in the default prop_cycle', fontsize='large')
#plt.show()
plt.savefig("Colors_in_the_default_prop_cycle.eps", dpi=None, facecolor='w', edgecolor='w', orientation='portrait', format="eps", bbox_inches='tight')
print(plt.rcParams['axes.prop_cycle'].by_key()['color'])
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> git@github.com:lijin-THU/notes-python.git</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 基础</h3>
<div class="outline-text-3" id="text-8-1">
</div><div id="outline-container-sec-8-1-1" class="outline-4">
<h4 id="sec-8-1-1"><span class="section-number-4">8.1.1</span> 文件读写 <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-04 Tue&gt;</span></span></h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
url: <a href="https://github.com/lijin-THU/notes-python/blob/master/02-python-essentials/02.21-file-IO.ipynb">https://github.com/lijin-THU/notes-python/blob/master/02-python-essentials/02.21-file-IO.ipynb</a>
Control + RightClick
</p>
</div>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> numpy <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-04 Tue 11:14&gt;</span></span></h3>
<div class="outline-text-3" id="text-8-2">
</div><div id="outline-container-sec-8-2-1" class="outline-4">
<h4 id="sec-8-2-1"><span class="section-number-4">8.2.1</span> overview <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-08 Sat&gt;</span></span></h4>
<div class="outline-text-4" id="text-8-2-1">
<ul class="org-ul">
<li>numpy中array()方法与基本库中list有很大不同，注意不要混淆！！！
</li>
<li>修改array的形状,shape方法
</li>
<li>*乘法仍然是对应元素的乘积，并不是按照矩阵乘法来计算
</li>
<li>矩阵乘法为A.dot(b)
</li>
<li>numpy.linspace(start<sub>point</sub>, end<sub>point</sub>, point<sub>number</sub>)
</li>
<li>从数组中选择元素src<sub>python</sub>{numpy.array(list)[\[False, Ture, False, True\]]}
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">a = [1, 2, 3, 9]
import numpy
b = numpy.array(a)
print(a * 2)
print(b * 2)
#print(a.shape)
print(b.shape)
b.shape = 2,2
print(b)
print(b * b)
c = numpy.linspace(0, 2*numpy.pi, 21)
sin_c = numpy.sin(c)
print(c)
print(sin_c)
print(sin_c &gt; 0.8)
print(c[sin_c &gt; 0.8])
print('s')
print(c[[False, False, False, True, True, True, True, True, False, False, False, False
, False, False, False, False, False, False, False, False, False]])
print(sin_c[sin_c &gt; 0.8])
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-2-2" class="outline-4">
<h4 id="sec-8-2-2"><span class="section-number-4">8.2.2</span> matplotlib basics <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-08 Sat 17:11&gt;</span></span></h4>
<div class="outline-text-4" id="text-8-2-2">
<ul class="org-ul">
<li>清除、关闭图像 clf(), close(), close('all')
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">from numpy import *
from matplotlib.pyplot import *
t = linspace(0, 2*pi, 50)
x = sin(t)
y = cos(t)
figure()
plot(x)
figure()
plot(y)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-2-3" class="outline-4">
<h4 id="sec-8-2-3"><span class="section-number-4">8.2.3</span> numpy array <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-08 Sat 18:12&gt;</span></span></h4>
<div class="outline-text-4" id="text-8-2-3">
<ul class="org-ul">
<li>查看形状, np.shape(a)
</li>
<li>查看元素数目, np.size(a)
</li>
<li>查看数组维数, np.ndim(b)
</li>
<li>与列表不同，数组中要求所有元素的 dtype 是一样的，
如果传入参数的类型与数组类型不一样，需要按照已有的类型进行转换
</li>
<li>多维数组索引, a[1, 3], a<sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup>
</li>
<li>切片是引用, 因此，改变 b 会改变 a 的值。与列表(list)不同
</li>
<li>np.arange 函数来产生等差数组
</li>
<li>花式索引需要指定索引位置, a[\[1, 2, -3\]]。还可以使用布尔数组来花式索引。
但是list不行。
</li>
<li>与切片不同，花式索引返回的是原对象的一个复制而不是引用
</li>
<li>where 函数会返回所有非零元素的索引
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">import numpy as np
a = [i for i in range(10)]
a.append('dog')
aa = [i for i in range(10)]
print(a)
b = np.array(a)
bb = np.array(aa)
print(b.dtype, b.itemsize, b.shape, np.shape(a), np.ndim(a))
c = np.arange(0, 10, 2)
d = range(0, 10, 2)
print(type(c), c &gt; 3, b[[0, 3, 2]], np.where(c[c &gt; 3]))
print(type(d))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-2-4" class="outline-4">
<h4 id="sec-8-2-4"><span class="section-number-4">8.2.4</span> array types <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-09 Sun 15:47&gt;</span></span></h4>
<div class="outline-text-4" id="text-8-2-4">
<ul class="org-ul">
<li>复数数组
</li>
<li>复共轭 a.conj()
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">import numpy as np
a = np.array([1 + 1j, 2, 3, 4])
print(a.real, a.imag, a.conj())
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-2-5" class="outline-4">
<h4 id="sec-8-2-5"><span class="section-number-4">8.2.5</span> array calculation method <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-09 Sun 16:57&gt;</span></span></h4>
<div class="outline-text-4" id="text-8-2-5">
<ul class="org-ul">
<li>求所有元素的和 sum(a)
</li>
<li>沿着第一维求和 sum(a, axis=0)
</li>
<li>沿着第二维求和 sum(a, axis=1)
</li>
<li>求所有元素的乘积 prod(a), a.prod()
</li>
<li>全局最小 a.min()
</li>
<li>沿着某个轴的最小 a.min(axis=1)
</li>
<li>最大最小值的位置 a.argmin(), a.argmax()
</li>
<li>均值 a.mean(axis=1)
</li>
<li>加权平均 a.average(axis=1), a.average(axis=0, weights=[1,2])
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2-6" class="outline-4">
<h4 id="sec-8-2-6"><span class="section-number-4">8.2.6</span> numpy sorting <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-09-09 Sun&gt;</span></span></h4>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> <span class="todo TODO">TODO</span> interfacing with other languages <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-10-03 Wed&gt;</span></span></h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>State "TODO"       from              <span class="timestamp-wrapper"><span class="timestamp">[2018-10-03 Wed 20:15]</span></span>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Coursera-ML-AndrewNg-Notes</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> <span class="timestamp-wrapper"><span class="timestamp">&lt;2019-03-30 六 01:00&gt;</span></span> 课时12 梯度下降</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>alpha是learning rate，可以是常数，不能太大或太小。
</li>
<li>应该同时更新Theta<sub>0</sub>,Theta<sub>1</sub>,&#x2026;Theta<sub>n</sub>
</li>
<li>事实证明线性回规的cost function都是弓形函数（凸函数，convex function），
只有一个全局最小，没有局部最小。
</li>
<li>batch Gradient Descent: 每次更新时遍历所有training set.
</li>
<li>也可以不遍历所有training set.
</li>
<li>Normal equation方法不适用于大量training set,梯度下降可以。
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> TensorFlow learning on Github</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> 疑问</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>变量的creation和initialization区别是什么？都在执行什么操作？
是否类似于C中的变量声明与定义？
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Handson-ml</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> numpy and pandas</h3>
<div class="outline-text-3" id="text-11-1">
</div><div id="outline-container-sec-11-1-1" class="outline-4">
<h4 id="sec-11-1-1"><span class="section-number-4">11.1.1</span> creating arrays and learning pandas <span class="timestamp-wrapper"><span class="timestamp">&lt;2020-01-23 Thu&gt;</span></span></h4>
<div class="outline-text-4" id="text-11-1-1">
<div class="org-src-container">

<pre class="src src-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
a = np.zeros(4)
b = np.ones((3,2))
#a.append(9)
print(a)
print(np.linspace(1,8,5))
print(b)
c = np.random.rand(20, 10)
fig = plt.figure(1, figsize=(7, 6))
plt.imshow(np.sin(c))
s = pd.Series(np.random.randn(5), index=['a','b','c','d','e'])
d = {'a' : 1, 'b' : 2, 'c' : 3, 'd' : 4}
s2 = pd.Series(d, index=['d','c','b'])
print(s)
print()
print(s[[2, 1]])
print(s[s &gt; 1])
print()
print(s2)
d2 = {'a':list(range(3)), 'b':list(range(3,6)), 'c':list(range(6,9))}
df = pd.DataFrame(d2, index=[1,2,3], columns=['first', 'second', 'a'])
print(df)
df2 = pd.DataFrame(d2)
print()
print(df2)
df3 = pd.DataFrame.from_dict(d2, orient='index', columns=list(range(3,6)))
print()
print(df3)
df3[9] = df3[5] &lt; 5
df3[7] = df3[3] + 1
print()
print(df3)
df3.pop(9)
print()
print(df3)
df3['ex'] = [1, 3, 4]
print()
print(df3)
df4 = df3.assign(ex2=df3[4]//4.)
print()
print(df4)
#plt.show()
#return 'python-matplot-fig2.png' # return filename to org-mode
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Li Gao-Yang</p>
<p class="date">Created: 2020-02-10 一 15:40</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
